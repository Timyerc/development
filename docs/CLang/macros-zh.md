# 宏定义

## 对象型宏

对象型宏是一个简单的标识符，它将被代码片段替换。之所以称为对象型，是因为它在使用的代码中看起来像一个数据对象。它们最常用于为数值常量提供符号名称。

您可以使用 `#define` 指令创建宏。`#define` 后面跟着宏的名称，然后是它应缩写的标记序列，这通常被称为宏的主体、扩展或替换列表。例如：

```
#define BUFFER_SIZE 1024
```
这定义了一个名为 **BUFFER_SIZE** 的宏，作为标记 1024 的缩写。如果在这个 `#define` 指令之后的某个地方有如下 C 语句：

```
foo = (char *) malloc (BUFFER_SIZE);
```
那么 C 预处理器将识别并扩展宏 **BUFFER_SIZE**。C 编译器将看到与您直接编写：

```
foo = (char *) malloc (1024);
```
相同的标记。

按照惯例，宏名称用大写字母书写。当可以一眼看出哪些名称是宏时，程序更容易阅读。

宏的主体在 `#define` 行的末尾结束。如果需要，您可以使用反斜杠换行将定义延续到多行。然而，当宏被扩展时，它将全部显示在一行。例如：

```
#define NUMBERS 1, \
                2, \
                3
int x[] = { NUMBERS };
     → int x[] = { 1, 2, 3 };
```     
这最常见的可见结果是错误消息中令人惊讶的行号。

在宏主体中没有限制，只要它能够分解为有效的预处理标记。括号不需要平衡，主体不需要类似于有效的 C 代码。（如果不类似，使用宏时可能会收到 C 编译器的错误消息。）

C 预处理器顺序扫描您的程序。宏定义在您编写它们的位置生效。因此，以下输入给 C 预处理器：

```
foo = X;
#define X 4
bar = X;
```
生成：

```
foo = X;
bar = 4;
```

当预处理器扩展宏名称时，宏的扩展替换宏调用，然后检查扩展是否还有更多宏可扩展。例如：

```
#define TABLESIZE BUFSIZE
#define BUFSIZE 1024
TABLESIZE
     → BUFSIZE
     → 1024
```
**TABLESIZE** 首先扩展为 **BUFSIZE**，然后该宏扩展为最终结果 1024。

请注意，**BUFSIZE** 在定义 **TABLESIZE** 时并未定义。**TABLESIZE** 的 `#define` 精确使用您指定的扩展——在这种情况下，**BUFSIZE**——并且不会检查它是否也包含宏名称。只有在使用 **TABLESIZE** 时，它的扩展结果才会被扫描以寻找更多宏名称。

如果您在源文件的某个地方更改了 **BUFSIZE** 的定义，这将有所不同。**TABLESIZE**，如上所示定义，将始终使用当前生效的 **BUFSIZE** 的定义扩展：

```
#define BUFSIZE 1020
#define TABLESIZE BUFSIZE
#undef BUFSIZE
#define BUFSIZE 37
```
现在 **TABLESIZE** 在两个阶段中扩展为 37。

## 函数型宏

您还可以定义看起来像函数调用的宏。这些称为函数型宏。要定义一个函数型宏，您使用相同的 `#define` 指令，但在宏名称后立即放置一对括号。例如：

```
#define lang_init()  c_init()
lang_init()
     → c_init()
```

只有当宏名称后面带有一对括号时，函数型宏才会被扩展。如果您只写名称，它将保持不变。这在您有一个函数和一个同名宏，并希望有时使用该函数时会很有用。

```
extern void foo(void);
#define foo() /* 优化的内联版本 */
…
  foo();
  funcptr = foo;
```

在这里，`foo()` 的调用将使用宏，但函数指针将获得实际函数的地址。如果宏被扩展，将会导致语法错误。

如果您在宏定义中在宏名称和括号之间放置空格，这并不定义函数型宏，而是定义一个对象型宏，其扩展恰好以一对括号开始。

```
#define lang_init ()    c_init()
lang_init()
     → () c_init()()
```

在这个扩展中，前两对括号来自宏。第三对是原本在宏调用后面的括号。由于 **lang_init** 是一个对象型宏，它并不会消耗那些括号。

## 宏参数

函数型宏可以接受参数，就像真实的函数一样。要定义一个使用参数的宏，您需要在宏定义中插入参数，这些参数放在使宏具有函数特性的括号之间。参数必须是有效的 C 标识符，用逗号分隔，并且可以包含可选的空格。

要调用一个接受参数的宏，您写下宏的名称，后面跟着用括号括起来的实际参数列表，参数之间用逗号分隔。宏的调用不必局限于单一逻辑行——它可以跨越源文件中的多行。您提供的参数数量必须与宏定义中的参数数量匹配。当宏被扩展时，其主体中的每个参数都会被相应参数的标记替换。（您不需要在宏主体中使用所有参数。）

例如，这里有一个宏，它计算两个数值的最小值，这是在许多 C 程序中定义的，以及一些用法。

```
#define min(X, Y)  ((X) < (Y) ? (X) : (Y))
  x = min(a, b);          →  x = ((a) < (b) ? (a) : (b));
  y = min(1, 2);          →  y = ((1) < (2) ? (1) : (2));
  z = min(a + 28, *p);    →  z = ((a + 28) < (*p) ? (a + 28) : (*p));
```

（在这个小示例中，您已经可以看到宏参数的一些危险。请参见《宏陷阱》，获取详细解释。）

每个参数的前导和尾随空格会被去掉，参数中标记之间的所有空格会被减少为一个空格。每个参数中的括号必须平衡；而括号中的逗号不会结束该参数。然而，方括号或花括号不需要平衡，并且它们不会妨碍逗号分隔参数。因此，

```
macro (array[x = y, x + 1])
```

将两个参数传递给 `macro: array[x = y` 和 `x + 1]`。如果您想将 `array[x = y, x + 1]` 作为参数提供，可以写成 `array[(x = y, x + 1)]`，这在 C 代码中是等效的。

所有宏的参数在替换到宏主体之前，都会完全进行宏扩展。替换后，完整的文本会再次被扫描以寻找需要扩展的宏，包括参数。这个规则可能看起来奇怪，但它经过精心设计，以便您无需担心任何函数调用是否实际上是宏调用。不过，如果您试图过于聪明，可能会遇到麻烦。请参见《参数预扫描》，以获取详细讨论。

例如，`min (min (a, b), c)` 首先扩展为：

```
min (((a) < (b) ? (a) : (b)), (c))
```

然后扩展为：

```
((((a) < (b) ? (a) : (b))) < (c)
 ? (((a) < (b) ? (a) : (b)))
 : (c))
```

（这里为了清晰显示的换行实际上不会生成。）

您可以将宏参数留空；这对预处理器来说不是错误（但许多宏会因此扩展为无效代码）。您不能完全省略参数；如果一个宏接受两个参数，参数列表的顶部必须有一个逗号。以下是一些使用 `min` 的搞笑示例：

```
min(, b)        → ((   ) < (b) ? (   ) : (b))
min(a, )        → ((a  ) < ( ) ? (a  ) : (  ))
min(,)          → ((   ) < ( ) ? (   ) : (  ))
min((,),)       → (((,)) < ( ) ? ((,)) : ( ))

min()      error→ macro "min" requires 2 arguments, but only 1 given
min(,,)    error→ macro "min" passed 3 arguments, but takes just 2
```

空格不是预处理标记，因此如果宏 `foo` 接受一个参数，`foo ()` 和 `foo ( )` 都提供了一个空参数。以前的 GNU 预处理器实现和文档在这一点上是不正确的，坚称如果需要空参数，接受单个参数的函数型宏必须传递一个空格。

出现在字符串字面量中的宏参数不会被相应的实际参数替换。

```          
#define foo(x) x, "x"
foo(bar)        → bar, "x"
```

## 字符串化

有时您可能希望将宏参数转换为字符串常量。在字符串常量内部，参数不会被替换，但您可以使用 `#` 预处理操作符。当宏参数与前导 `#` 一起使用时，预处理器将其替换为实际参数的文字文本，并将其转换为字符串常量。与普通的参数替换不同，参数不会首先进行宏扩展。这被称为字符串化。

没有办法将参数与周围文本组合并一起进行字符串化。相反，您可以编写一系列相邻的字符串常量和字符串化的参数。预处理器将字符串化的参数替换为字符串常量。然后，C 编译器将所有相邻的字符串常量组合成一个长字符串。

下面是一个使用字符串化的宏定义示例：

```
#define WARN_IF(EXP) \
do { if (EXP) \
        fprintf (stderr, "Warning: " #EXP "\n"); } \
while (0)
WARN_IF (x == 0);
     → do { if (x == 0)
           fprintf (stderr, "Warning: " "x == 0" "\n"); } while (0);
```

`EXP` 的参数在 if 语句中被替换一次，原样插入，在 `fprintf` 的参数中被字符串化一次。如果 `x` 是一个宏，它会在 `if` 语句中被扩展，但在字符串中不会。

`do` 和 `while (0)` 是一种变通方法，使得可以编写 `WARN_IF (arg)`；由于 `WARN_IF` 与函数的相似性，C 程序员会想要这样做；请参见《吞掉分号》。

在 C 中，字符串化不仅仅是将双引号字符放在片段周围。预处理器会转义嵌入的字符串常量周围的引号和所有字符串和字符常量中的反斜杠，以生成一个具有正确内容的有效 C 字符串常量。因此，字符串化 `p = "foo\n"`; 的结果是 `"p = \"foo\\n\";"`。然而，不在字符串或字符常量内部的反斜杠不会被复制：单独的 `'\n'` 字符串化为 `"\n"`。

在字符串化的文本中，所有前导和尾随空格都会被忽略。文本中间的任何空格序列都会在字符串化结果中转换为一个空格。注释在字符串化发生之前很久就已被空格替换，因此它们不会出现在字符串化的文本中。

没有办法将宏参数转换为字符常量。

如果您想要字符串化宏参数的扩展结果，则必须使用两级宏。

```
#define xstr(s) str(s)
#define str(s) #s
#define foo 4
str (foo)
     → "foo"
xstr (foo)
     → xstr (4)
     → str (4)
     → "4"
```

当 `s` 在 `str` 中使用时，它被字符串化，因此不会首先进行宏扩展。但 `s` 是 `xstr` 的普通参数，因此在扩展 `xstr` 之前，它会完全进行宏扩展（参见《参数预扫描》）。因此，当 `str` 到达其参数时，它已经被宏扩展过。

## 连接

在扩展宏时，将两个标记合并为一个通常是有用的。这被称为标记粘贴或标记连接。`##` 预处理操作符执行标记粘贴。当宏被扩展时，`##` 操作符两侧的两个标记会合并成一个单一的标记，然后替换 `##` 及宏扩展中的两个原始标记。通常这两个标记都是标识符，或者一个是标识符而另一个是预处理数字。当粘贴时，它们形成一个更长的标识符。这并不是唯一有效的情况。也可以将两个数字（或一个数字和一个名称，例如 `1.5` 和 `e3`）连接成一个数字。此外，还可以通过标记粘贴形成多字符操作符，如 `+=`。

然而，两个不能组合成有效标记的标记不能被粘贴在一起。例如，您不能将 `x` 与 `+` 以任何顺序连接。如果您尝试，预处理器会发出警告并输出这两个标记。它是否在标记之间放置空格是未定义的。在复杂宏中，常常会发现不必要使用 `##` 的情况。如果您收到此警告，您很可能可以简单地删除 `##`。

通过 `##` 合并的两个标记可以来自宏体，但您也可以一开始就将它们写为一个标记。标记粘贴在一个或两个标记来自宏参数时最有用。如果 `##` 相邻的任何一个标记是参数名，它在 `##` 执行之前会被实际参数替换。与字符串化一样，实际参数不会首先进行宏扩展。如果参数为空，则该 `##` 没有任何效果。

请记住，C 预处理器在考虑宏之前会将注释转换为空格。因此，您无法通过连接 `/` 和 `*` 来创建注释。您可以在 `##` 与其操作数之间放置任意多的空格，包括注释，并且可以在将要连接的参数中放置注释。然而，如果 `##` 出现在宏体的任一端，则会导致错误。

考虑一个解释命名命令的 C 程序。可能需要一个命令表，也许是声明如下的结构体数组：

```
struct command
{
  char *name;
  void (*function) (void);
};
```

```
struct command commands[] =
{
  { "quit", quit_command },
  { "help", help_command },
  …
};
```

不需要在字符串常量和函数名称中各给一次命令名称会更简洁。一个以命令名称作为参数的宏可以使这变得不必要。字符串常量可以通过字符串化创建，而函数名称可以通过将参数与 `_command` 连接来生成。下面是具体做法：

```
#define COMMAND(NAME)  { #NAME, NAME ## _command }

struct command commands[] =
{
  COMMAND (quit),
  COMMAND (help),
  …
};
```

## 可变参数宏

宏可以声明为接受可变数量的参数，就像函数一样。定义宏的语法与函数相似。以下是一个示例：

```
#define eprintf(...) fprintf (stderr, __VA_ARGS__)
```

这种类型的宏称为可变参数宏。当调用宏时，在最后一个命名参数（该宏没有）之后，参数列表中的所有标记，包括任何逗号，成为可变参数。这些标记序列替换宏体中的标识符 `__VA_ARGS__`，无论它出现在哪里。因此，我们有以下扩展：

```
eprintf ("%s:%d: ", input_file, lineno)
     →  fprintf (stderr, "%s:%d: ", input_file, lineno)
```

可变参数在插入到宏扩展之前会完全宏扩展，就像普通参数一样。您可以使用 `#` 和 `##` 操作符来字符串化可变参数或将其前导或后缀标记与另一个标记粘贴在一起。（但请参阅下面关于 `##` 的重要特殊情况。）

如果您的宏比较复杂，您可能想为可变参数使用一个比 `__VA_ARGS__` 更具描述性的名称。CPP 允许这样做，作为一种扩展。您可以在 `...` 之前立即写一个参数名；该名称用于可变参数。上述的 `eprintf` 宏可以这样写：

```
#define eprintf(args...) fprintf (stderr, args)
```

使用这个扩展。您不能在同一个宏中同时使用 `__VA_ARGS__` 和这个扩展。

您可以在可变参数宏中同时拥有命名参数和可变参数。我们也可以像这样定义 `eprintf`：

```
#define eprintf(format, ...) fprintf (stderr, format, __VA_ARGS__)
```

这种写法看起来更具描述性，但在历史上它的灵活性较低：您必须在格式字符串后提供至少一个参数。在标准 C 中，您不能省略分隔命名参数和可变参数的逗号。（注意，这一限制在 C++2a 中被取消，而在 GNU C 中从未存在；见下文。）

此外，如果您将可变参数留空，您会得到一个语法错误，因为格式字符串后会有一个额外的逗号。

```
eprintf("success!\n", );
     → fprintf(stderr, "success!\n", );
```

在 C++2a 中，这个问题已经得到解决，GNU CPP 也有一对扩展来处理这个问题。

首先，在 GNU CPP 中，以及 C++2a 开始的 C++ 中，您可以完全省略可变参数：

```          
eprintf ("success!\n")
     → fprintf(stderr, "success!\n", );
```

其次，C++2a 引入了 `__VA_OPT__` 函数宏。此宏只能出现在可变参数宏的定义中。如果可变参数有任何标记，则 `__VA_OPT__` 调用扩展为其参数；但如果可变参数没有任何标记，`__VA_OPT__` 则扩展为空：

```
#define eprintf(format, ...) \
  fprintf (stderr, format __VA_OPT__(,) __VA_ARGS__)
```

`__VA_OPT__` 在 GNU C 和 GNU C++ 中也可用。

历史上，GNU CPP 还有另一个扩展来处理尾部逗号：在逗号和可变参数之间放置的 `##` 标记粘贴操作符具有特殊含义。尽管引入了 `__VA_OPT__`，此扩展仍在 GNU CPP 中受支持，以便向后兼容。如果您写：

```
#define eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)
```

并且在使用 `eprintf` 宏时省略了可变参数，则在 `##` 之前的逗号将被删除。如果您传递一个空参数，或者在 `##` 之前的标记不是逗号，则不会发生这种情况。

```
eprintf ("success!\n")
     → fprintf(stderr, "success!\n");
```

以上解释在唯一的宏参数是可变参数的情况下是不明确的，因为尝试区分没有参数是否是空参数或缺少参数是没有意义的。CPP 在符合特定 C 标准时保留逗号。否则，逗号作为扩展将被删除。

C 标准规定，标识符 `__VA_ARGS__` 只能出现在可变参数宏的替换列表中。它不能用作宏名称、宏参数名称或在不同类型的宏中使用。在开放文本中也可能被禁止；标准是模糊的。我们建议您除非是出于定义目的，否则避免使用它。

同样，C++ 禁止在可变参数宏的替换列表之外使用 `__VA_OPT__`。

可变参数宏在 C99 中成为 C 语言的标准部分。GNU CPP 以前通过命名可变参数（`args...`，而不是 `...` 和 `__VA_ARGS__`）支持它们，这在向后兼容性中仍然受到支持。

## 取消定义和重新定义宏

如果一个宏不再有用，可以使用 `#undef` 指令将其取消定义。`#undef` 只接受一个参数，即要取消定义的宏的名称。您需要使用宏的名称，尽管该宏是类似函数的。如果在宏名称后面有任何内容出现，则会报错。如果名称不是宏，`#undef` 将没有效果。

```
#define FOO 4
x = FOO;        → x = 4;
#undef FOO
x = FOO;        → x = FOO
```

一旦宏被取消定义，该标识符可以通过后续的 `#define` 指令重新定义为宏。新的定义不需要与旧的定义有任何相似之处。

然而，如果一个当前是宏的标识符被重新定义，则新的定义必须与旧的定义在实际效果上相同。两个宏定义在实际效果上相同的条件是：

* 两者都是相同类型的宏（对象宏或函数宏）。
* 替换列表中的所有标记都相同。
* 如果有参数，它们是相同的。
* 空格出现在两个定义中的相同位置。虽然空格的数量不必完全相同，但要记住，注释也算作空格。

以下定义在实际效果上是相同的：

```
#define FOUR (2 + 2)
#define FOUR         (2    +    2)
#define FOUR (2 /* two */ + 2)
```

但以下定义则不是：

```          
#define FOUR (2 + 2)
#define FOUR ( 2+2 )
#define FOUR (2 * 2)
#define FOUR(score,and,seven,years,ago) (2 + 2)
```

如果宏被重新定义为一个与旧定义在实际效果上不相同的定义，预处理器会发出警告，并使用新的定义。如果新的定义在实际效果上相同，则重新定义会被静默忽略。这允许例如两个不同的头文件定义一个公共宏。只有在定义不匹配时，预处理器才会发出警告。